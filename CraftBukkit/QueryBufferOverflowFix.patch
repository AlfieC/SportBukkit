From cd3333620c962d3c51246b3dbff562a7fbdd232f Mon Sep 17 00:00:00 2001
From: mrapple <tony@oc.tc>
Date: Sun, 2 Sep 2012 12:28:34 -0500
Subject: [PATCH] Prevent buffer overflow when writing response data on RCON
 query, fixes BUKKIT-2459

---
 .../net/minecraft/server/RemoteStatusListener.java |  295 ++++++++++++++++++++
 1 files changed, 295 insertions(+), 0 deletions(-)
 create mode 100644 src/main/java/net/minecraft/server/RemoteStatusListener.java

diff --git a/src/main/java/net/minecraft/server/RemoteStatusListener.java b/src/main/java/net/minecraft/server/RemoteStatusListener.java
new file mode 100644
index 0000000..798d436
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RemoteStatusListener.java
@@ -0,0 +1,295 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.PortUnreachableException;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import net.minecraft.server.IMinecraftServer;
+import net.minecraft.server.RemoteConnectionThread;
+import net.minecraft.server.RemoteStatusChallenge;
+import net.minecraft.server.RemoteStatusReply;
+import net.minecraft.server.StatusChallengeUtils;
+
+public class RemoteStatusListener extends RemoteConnectionThread {
+
+    private long clearedTime;
+    private int bindPort;
+    private int serverPort;
+    private int maxPlayers;
+    private String localAddress;
+    private String worldName;
+    private DatagramSocket socket = null;
+    private byte[] n = new byte[1460];
+    private DatagramPacket o = null;
+    private Map p;
+    private String hostname;
+    private String motd;
+    private Map challenges;
+    private long t;
+    private RemoteStatusReply cachedReply;
+    private long cacheTime;
+
+    public RemoteStatusListener(IMinecraftServer var1) {
+        super(var1);
+        this.bindPort = var1.a("query.port", 0);
+        this.motd = var1.u();
+        this.serverPort = var1.v();
+        this.localAddress = var1.w();
+        this.maxPlayers = var1.z();
+        this.worldName = var1.J();
+        this.cacheTime = 0L;
+        this.hostname = "0.0.0.0";
+        if (0 != this.motd.length() && !this.hostname.equals(this.motd)) {
+            this.hostname = this.motd;
+        }
+        else {
+            this.motd = "0.0.0.0";
+            try {
+                InetAddress var2 = InetAddress.getLocalHost();
+                this.hostname = var2.getHostAddress();
+            }
+            catch (UnknownHostException var3) {
+                this.warning("Unable to determine local host IP, please set server-ip in \'" + var1.b_() + "\' : " + var3.getMessage());
+            }
+        }
+        if (0 == this.bindPort) {
+            this.bindPort = this.serverPort;
+            this.info("Setting default query port to " + this.bindPort);
+            var1.a("query.port", (Object)Integer.valueOf(this.bindPort));
+            var1.a("debug", (Object)Boolean.valueOf(false));
+            var1.a();
+        }
+        this.p = new HashMap();
+        this.cachedReply = new RemoteStatusReply(1460);
+        this.challenges = new HashMap();
+        this.t = (new Date()).getTime();
+    }
+
+    private void send(byte[] var1, DatagramPacket var2) {
+        // CraftBukkit start - catch possible exceptions
+        try {
+            this.socket.send(new DatagramPacket(var1, var1.length, var2.getSocketAddress()));
+        } catch (Exception e) {
+            this.warning("Could not send data: " + e.getMessage());
+        }
+        // CraftBukkit end
+    }
+
+    private boolean parsePacket(DatagramPacket var1) {
+        byte[] var2 = var1.getData();
+        int var3 = var1.getLength();
+        SocketAddress var4 = var1.getSocketAddress();
+        this.debug("Packet len " + var3 + " [" + var4 + "]");
+        if (3 <= var3 && -2 == var2[0] && -3 == var2[1]) {
+            this.debug("Packet \'" + StatusChallengeUtils.a(var2[2]) + "\' [" + var4 + "]");
+            switch (var2[2]) {
+                case 0:
+                    if (!this.hasChallenged(var1).booleanValue()) {
+                        this.debug("Invalid challenge [" + var4 + "]");
+                        return false;
+                    }
+                    else if (15 == var3) {
+                        this.send(this.getFullReply(var1), var1);
+                        this.debug("Rules [" + var4 + "]");
+                    }
+                    else {
+                        RemoteStatusReply var5 = new RemoteStatusReply(1460);
+                        var5.write((int)0);
+                        var5.write(this.getIdentityToken(var1.getSocketAddress()));
+                        var5.write(this.localAddress);
+                        var5.write("SMP");
+                        var5.write(this.worldName);
+                        var5.write(Integer.toString(this.d()));
+                        var5.write(Integer.toString(this.maxPlayers));
+                        var5.write((short)this.serverPort);
+                        var5.write(this.hostname);
+                        this.send(var5.getBytes(), var1);
+                        this.debug("Status [" + var4 + "]");
+                    }
+                case 9:
+                    this.createChallenge(var1);
+                    this.debug("Challenge [" + var4 + "]");
+                    return true;
+                default:
+                    return true;
+            }
+        }
+        else {
+            this.debug("Invalid packet [" + var4 + "]");
+            return false;
+        }
+    }
+
+    private byte[] getFullReply(DatagramPacket var1) {
+        long var2 = System.currentTimeMillis();
+        if (var2 < this.cacheTime + 5000L) {
+            byte[] var7 = this.cachedReply.getBytes();
+            byte[] var8 = this.getIdentityToken(var1.getSocketAddress());
+            var7[1] = var8[0];
+            var7[2] = var8[1];
+            var7[3] = var8[2];
+            var7[4] = var8[3];
+            return var7;
+        }
+        else {
+            this.cacheTime = var2;
+            this.cachedReply.reset();
+            this.cachedReply.write((int)0);
+            this.cachedReply.write(this.getIdentityToken(var1.getSocketAddress()));
+            this.cachedReply.write("splitnum");
+            this.cachedReply.write((int)128);
+            this.cachedReply.write((int)0);
+            this.cachedReply.write("hostname");
+            this.cachedReply.write(this.localAddress);
+            this.cachedReply.write("gametype");
+            this.cachedReply.write("SMP");
+            this.cachedReply.write("game_id");
+            this.cachedReply.write("MINECRAFT");
+            this.cachedReply.write("version");
+            this.cachedReply.write(this.server.getVersion());
+            this.cachedReply.write("plugins");
+            this.cachedReply.write(this.server.getPlugins());
+            this.cachedReply.write("map");
+            this.cachedReply.write(this.worldName);
+            this.cachedReply.write("numplayers");
+            this.cachedReply.write("" + this.d());
+            this.cachedReply.write("maxplayers");
+            this.cachedReply.write("" + this.maxPlayers);
+            this.cachedReply.write("hostport");
+            this.cachedReply.write("" + this.serverPort);
+            this.cachedReply.write("hostip");
+            this.cachedReply.write(this.hostname);
+            this.cachedReply.write((int)0);
+            this.cachedReply.write((int)1);
+            this.cachedReply.write("player_");
+            this.cachedReply.write((int)0);
+            String[] var4 = this.server.getPlayers();
+
+            // CraftBukkit start - use int instead of byte to prevent overflow
+            int var5 = (byte)var4.length;
+
+            for (int var6 = var5 - 1; var6 >= 0; --var6) {
+                // CraftBukkit end
+                this.cachedReply.write(var4[var6]);
+            }
+            this.cachedReply.write((int)0);
+            return this.cachedReply.getBytes();
+        }
+    }
+
+    private byte[] getIdentityToken(SocketAddress var1) {
+        return ((RemoteStatusChallenge)this.challenges.get(var1)).getIdentityToken();
+    }
+
+    private Boolean hasChallenged(DatagramPacket var1) {
+        SocketAddress var2 = var1.getSocketAddress();
+        if (!this.challenges.containsKey(var2)) {
+            return Boolean.valueOf(false);
+        }
+        else {
+            byte[] var3 = var1.getData();
+            return ((RemoteStatusChallenge)this.challenges.get(var2)).getToken() != StatusChallengeUtils.c(var3, 7, var1.getLength()) ? Boolean.valueOf(false) : Boolean.valueOf(true);
+        }
+    }
+
+    private void createChallenge(DatagramPacket var1) {
+        RemoteStatusChallenge var2 = new RemoteStatusChallenge(this, var1);
+        this.challenges.put(var1.getSocketAddress(), var2);
+        this.send(var2.getChallengeResponse(), var1);
+    }
+
+    private void cleanChallenges() {
+        if (this.running) {
+            long var1 = System.currentTimeMillis();
+            if (var1 >= this.clearedTime + 30000L) {
+                this.clearedTime = var1;
+                Iterator var3 = this.challenges.entrySet().iterator();
+                while (var3.hasNext()) {
+                    Entry var4 = (Entry)var3.next();
+                    if (((RemoteStatusChallenge)var4.getValue()).isExpired(var1).booleanValue()) {
+                        var3.remove();
+                    }
+                }
+            }
+        }
+    }
+
+    public void run() {
+        this.info("Query running on " + this.motd + ":" + this.bindPort);
+        this.clearedTime = System.currentTimeMillis();
+        this.o = new DatagramPacket(this.n, this.n.length);
+        try {
+            while (this.running) {
+                try {
+                    this.socket.receive(this.o);
+                    this.cleanChallenges();
+                    this.parsePacket(this.o);
+                }
+                catch (SocketTimeoutException var7) {
+                    this.cleanChallenges();
+                }
+                catch (PortUnreachableException var8) {
+                    ;
+                }
+                catch (IOException var9) {
+                    this.a(var9);
+                }
+            }
+        }
+        finally {
+            this.e();
+        }
+    }
+
+    public void a() {
+        if (!this.running) {
+            if (0 < this.bindPort && '\uffff' >= this.bindPort) {
+                if (this.g()) {
+                    super.a();
+                }
+            }
+            else {
+                this.warning("Invalid query port " + this.bindPort + " found in \'" + this.server.b_() + "\' (queries disabled)");
+            }
+        }
+    }
+
+    private void a(Exception var1) {
+        if (this.running) {
+            this.warning("Unexpected exception, buggy JRE? (" + var1.toString() + ")");
+            if (!this.g()) {
+                this.error("Failed to recover from buggy JRE, shutting down!");
+                this.running = false;
+            }
+        }
+    }
+
+    private boolean g() {
+        try {
+            this.socket = new DatagramSocket(this.bindPort, InetAddress.getByName(this.motd));
+            this.a(this.socket);
+            this.socket.setSoTimeout(500);
+            return true;
+        }
+        catch (SocketException var2) {
+            this.warning("Unable to initialise query system on " + this.motd + ":" + this.bindPort + " (Socket): " + var2.getMessage());
+        }
+        catch (UnknownHostException var3) {
+            this.warning("Unable to initialise query system on " + this.motd + ":" + this.bindPort + " (Unknown Host): " + var3.getMessage());
+        }
+        catch (Exception var4) {
+            this.warning("Unable to initialise query system on " + this.motd + ":" + this.bindPort + " (E): " + var4.getMessage());
+        }
+        return false;
+    }
+}
--
1.7.4.4

